# Practical React Hooks: How to refactor your app to use Hooks

Table of Contents

- [Practical React Hooks: How to refactor your app to use Hooks](#practical-react-hooks-how-to-refactor-your-app-to-use-hooks)
  - [1. Converting a class component to a function component](#1-converting-a-class-component-to-a-function-component)
    - [1. Class component without state or lifecycle methods](#1-class-component-without-state-or-lifecycle-methods)
    - [2. Class component with props, some default prop values, and propType declarations](#2-class-component-with-props-some-default-prop-values-and-proptype-declarations)
    - [3. Class component with state (single or few multiple keys)](#3-class-component-with-state-single-or-few-multiple-keys)
  - [2. Simplifying lifecycle methods](#2-simplifying-lifecycle-methods)
    - [1. Comparing useEffect object values](#1-comparing-useeffect-object-values)
      - [Solution 1 Use `JSON.stringify`](#solution-1-use-jsonstringify)
      - [Solution 2 Use a manual conditional check](#solution-2-use-a-manual-conditional-check)
      - [Solution 3 Use the useMemo Hook](#solution-3-use-the-usememo-hook)
  - [3. A safer way to refactor your render props API](#3-a-safer-way-to-refactor-your-render-props-api)
  - [4. Handling state initializers](#4-handling-state-initializers)


## 1. Converting a class component to a function component

The challenge is simple: How do you refactor your class components to function components without breaking any functionalities?

Well, let’s have a look at some of the most common cases you’ll encounter, starting with the easiest.

### 1. Class component without state or lifecycle methods

```javascript
// before
import React, {Component} from 'react';

class App extends Component {
  handleClick = () => {
    console.log("helloooooo")
  }

  render() {
    return <div>
      Hello World
      <button onClick={this.handleClick}>
        Click me!
      </button>
    </div>
  }
}

export default App
```
Refactoring this component is pretty straightforward. Here you go:


```javascript
// after
import React from 'react'

function App() {
  const handleClick = () => {
    console.log("helloooooo")
  }

  return <div>
      Hello World
      <button onClick={handleClick}> Click me! </button>
    </div>
}

export default App
```

What’s different here?

- No class keyword; replace with a JavaScript function
- No this in a function component; replace with a JavaScript value in the function scope

That’s all — nothing major here. Let’s move on

### 2. Class component with props, some default prop values, and propType declarations


```javascript
// before
class App extends Component {
  static propTypes = {
    name: PropTypes.string
  }
  static defaultProps = {
    name: "Hooks"
  }

  handleClick = () => {
    console.log("helloooooo")
  }

  render() {
    return <div>
      Hello {this.props.name}
      <button onClick={this.handleClick}> Click me! </button>
    </div>
  }
}
```
Upon refactoring, we have this:

```javascript
function App({name = "Hooks"}) {
  const handleClick = () => {
    console.log("helloooooo")
  }

  return <div>
      Hello {name}
      <button onClick={handleClick}>Click me! </button>
    </div>
}

App.propTypes = {
  name: PropTypes.number
}
```
The component looks a lot simpler as a functional component. The props become function parameters, default props are handled via the ES6 default parameter syntax, and static propTypes is replaced with App.propTypes. That’s about it!


### 3. Class component with state (single or few multiple keys)

The scenario gets more interesting when you have a class component with an actual state object. A lot of your class components will fall into this category or a slightly more complex version of this category.


```javascript
class App extends Component {
  state = {
    age: 19
  }

  handleClick = () => {
    this.setState((prevState) => ({age: prevState.age + 1}))
  }

  render() {
    return <div>
      Today I am {this.state.age} Years of Age
      <div>
        <button onClick={this.handleClick}>Get older! </button>
      </div>
    </div>
  }
}
```
The component only keeps track of a single property in the state object. Easy enough!

We can refactor this to use the `useState` Hook, as shown below:

```javascript
function App() {
  const [age, setAge] = useState(19);
  const [status, setStatus] = useState('married')
  const [siblings, setSiblings] = useState(10)


  const handleClick = () => setAge(age + 1)

  return (
   <div>
      Today I am {age} Years of Age
      <div>
        <button onClick={handleClick}>Get older! </button>
      </div>
   </div>
  )
}
```

## 2. Simplifying lifecycle methods

Another common challenge you’ll face will be refactoring the logic in your component’s componentDidMount, componentWillUnmount, and componentDidUpdate lifecycle methods.

The useEffect Hook is the perfect place to have this logic extracted. By default, the effect function within useEffect will be run after every render. This is common knowledge if you’re familiar with Hooks.

```javascript
import { useEffect } from 'react'
useEffect(() => {
   // your logic goes here
   // optional: return a function for canceling subscriptions
   return () => {}
})
```

An interesting feature of the useEffect Hook is the second argument you could pass in: the dependency array.

Consider the example of an empty dependency array, shown below:


```javascript
import { useEffect } from 'react'
useEffect(() => {

}, []) // 👈 array argument
```

Passing an empty array here will have the effect function run only when the component mounts and cleaned when it unmounts. This is ideal for cases where you want to track or fetch some data when the component mounts.

Here’s an example where you pass a value to the dependency array:

```javascript
import { useEffect } from 'react'
useEffect(() => {

}, [name]) // 👈 array argument with a value
```

The implication here is that the effect function will be invoked when the component mounts, and again any time the value of the name variable changes.

### 1. Comparing useEffect object values

The useEffect Hook takes in a function argument that possibly performs some side effects.

`useEffect(doSomething)`

However, the useEffect Hook also takes in a second argument: an array of values that the effect in the function depends on. For example:

`useEffect(doSomething, [name])`

In the code above, the doSomething function will only be run when the name value changes. This is a very useful feature, since you may not want the effect to run after every single render, which is the default behavior.

However, this poses another concern. In order for useEffect to call the doSomething function only when name has changed, it compares the previous name value to its current value, e.g., prevName === name.

This works great for primitive JavaScript value types.

But what if name was an object? `Objects in JavaScript are compared by reference!` Technically, if name was an object, then it’ll always be different on every render, so the check prevName === name will always be false.

By implication, the doSomething function will be run after every single render — which could be a performance concern depending on your application type. Are there any solutions to this?

Consider the trivial component below:

```javascript
function RandomNumberGenerator () {
  const name = 'name'

  useEffect(
    () => {
      console.log('Effect has been run!')
    },
    [name]
  )

  const [randomNumber, setRandomNumber] = useState(0)

  return (
    <div>
      <h1>{randomNumber}</h1>
      <button
        onClick={() => {
          setRandomNumber(Math.random())
        }}
      >
        Generate random number!
      </button>
    </div>
  )
}
```

This component renders a button and a random number. Upon clicking the button, a new random number is generated.

Note that the useEffect Hook has the effect dependent on the name variable.

In this example, the name variable is a simple string. The effect will run when the component mounts; hence, console.log("Effect has been run!") will be invoked.

On subsequent renders, a shallow comparison will be made, e.g., is prevName === name where prevName represents the previous value of the name before a new render.

Strings are compared by value, so "name" === "name" is always true. Thus, the effect won’t be run.

Consequently, you get the log output Effect has been run! just once!

Now, change the `name` variable to an object.

```javascript
function RandomNumberGenerator() {
  // look here 👇
  const name = {firstName: "name"}

  useEffect(() => {
    console.log("Effect has been run!")
  }, [name])

  const [randomNumber, setRandomNumber] = useState(0);

  return (
    <div>
      <h1>{randomNumber}</h1>
      <button onClick={()=> setRandomNumber(Math.random())}>Generate random number!</button>
    </div>
  );
}
```

In this case, after the first render, the shallow check is carried out again. However, since objects are compared by reference — not by value — the comparison fails. For example, the following expression returns false:

```javascript
{firstName: "name"} === {firstName: "name"}
```

Consequently, the effect is run after every render, and you get a lot of logs.

How can we stop this from happening?

#### Solution 1 Use `JSON.stringify`

Here’s what this solution looks like:

```javascript
useEffect(() => {
    console.log("Effect has been run!")
}, [JSON.stringify(name)])
```

By using JSON.stringify(name), the value being compared is now a string and, as such, will be compared by value.

This works, but proceed with caution. Only use JSON.stringify on objects with not-so-complex values, and with easily serializable data types.

#### Solution 2 Use a manual conditional check

This solution involves keeping track of the previous value — in this case, name — and doing a deep comparison check on its current value.

It’s a little more code, but here’s how that works:


```javascript
// the isEqual function can come from anywhere
// - as long as you perform a deep check.
// This example uses a utility function from Lodash
import {isEqual} from 'lodash'

function RandomNumberGenerator() {
  const name = {firstName: "name"}

  useEffect(() => {
    if(!isEqual(prevName.current, name)) {
      console.log("Effect has been run!")
    }
  })

  const prevName = useRef;
  useEffect(() => {
    prevName.current = name
  })

  const [randomNumber, setRandomNumber] = useState(0);

  return <div>
    <h1> {randomNumber} </h1>
    <button onClick={() => { setRandomNumber(Math.random()) }}>
       Generate random number!
    </button>
  </div>
}
```
Now, we check if the values aren’t equal before running the effect:

```javascript
!isEqual(prevName.current, name)
```

But what’s prevName.current? With Hooks, you can use the useRef Hook to keep track of values. In the example above, the bit of code responsible for that is:


```javascript
const prevName = useRef;
useEffect(() => {
    prevName.current = name
})
```
This keeps track of the previous name used in the earlier useEffect Hook. I know this can be confusing to understand, so I’ve included a well-annotated version of the full code below:

```javascript
**
 * To read the annotations correctly, read all turtle comments first 🐢
 // - from top to bottom.
 * Then come back to read all unicorns 🦄 - from top to bottom.
 */


function RandomNumberGenerator() {
  // 🐢 1. The very first time this component is mounted,
  // the value of the name variable is set below
  const name = {firstName: "name"}

  // 🐢 2. This hook is NOT run. useEffect only runs sometime after render
  // 🦄 6. After Render this hook is now run.
  useEffect(() => {

  // 🦄 7. When the comparison happens, the hoisted value
  // of prevName.current is "undefined".
  // Hence, "isEqual(prevName.current, name)" returns "false"
  // as {firstName: "name"} is NOT equal to undefined.
    if(!isEqual(prevName.current, name)) {

  // 🦄 8. "Effect has been run!" is logged to the console.
  //console.log("Effect has been run!")
    }
  })

  // 🐢 3. The prevName constant is created to hold some ref.
  const prevName = useRef;

  // 🐢 4. This hook is NOT run
  // 🦄 9. The `order of your hooks matter!` After the first useEffect is run,
  // this will be invoked too.
  useEffect(() => {
    // 🦄 10. Now "prevName.current" will be set to "name".
    prevName.current = name;
   // 🦄 11. In subsequent renders, the prevName.current will now hold the same
    // object value - {firstName: "name"} which is alsways equal to the current
    // value in the first useEffect hook. So, nothing is logged to the console.
  // 🦄 12. The reason this effect holds the "previous" value is because
    // it'll always be run later than the first hook.
   })

  const [randomNumber, setRandomNumber] = useState(0)

  // 🐢 5. Render is RUN now - note that here, name is equal to the object,
  // {firstName: "name"} while the ref prevName.current holds no value.
  return
{randomNumber}
{ setRandomNumber(Math.random()) }}> Generate random number! }

```

#### Solution 3 Use the useMemo Hook

This solution is pretty elegant, in my opinion. Here’s what it looks like:

```javascript
function RandomNumberGenerator() {
  // look here 👇
  const name = useMemo(() => ({
    firstName: "name"
  }), [])

  useEffect(() => {
      console.log("Effect has been run!")
  }, [name])

  const [randomNumber, setRandomNumber] = useState(0)
  return (
    <div>
      <h1>{randomNumber}</h1>
      <button onClick={()=> setRandomNumber(Math.random()) }> Generate random number! </button>
    </div>
  )
}
```

The useEffect Hook still depends on the name value, but the name value here is memoized, provided by useMemo.

```javascript
const name = useMemo(() => ({
    firstName: "name"
}), [])
```

`useMemo` takes in a function that returns a certain value — in this case, the object `{firstName: "name"}`.

The second argument to `useMemo` is an array of dependencies that works just like those in `useEffect`. If no array is passed, then the value is recomputed on every render.

Passing an empty array computes the value on mounting the component without recomputing the value across renders. This keeps the `name` value the same (by reference) across renders.

Owing to the explanation above, the `useEffect` Hook now works as expected, without calling the effect multiple times, even though `name` is an object.

`name` is now a memoized object with the same reference across renders.

```javascript
useEffect(() => {
      console.log("Effect has been run!")
}, [name]) // 👈 name is memoized!
```

## 3. A safer way to refactor your render props API

Consider the following component that exposes a render prop API:

```javascript
class TrivialRenderProps extends Component {
  state = {
    loading: false,
    data: []
  }
  render() {
    return this.props.children(this.state)
  }
}
```

This is a contrived example, but good enough! Here’s an example of how this component will be used:

```javascript
function ConsumeTrivialRenderProps() {
  return <TrivialRenderProps>
    {({loading, data}) => {
      return <pre>
        {`loading: ${loading}`} <br />
        {`data: [${data}]`}
      </pre>
    }}
  </TrivialRenderProps>
}
```

Rendering the ConsumeTrivialRenderProps component just displays the value of the loading and data values as received from the render props API.

The problem with render props is that it can make your code look more nested than you’d like.

just wrap the component implementation within a custom Hook and return the same data as before. When done right, here’s how the refactored Hooks API will be consumed:

```javascript
function ConsumeTrivialRenderProps() {
  const { loading, setLoading, data } = useTrivialRenderProps()
  return <pre>
    {`loading: ${loading}`} <br />
    {`data: [${data}]`}
  </pre>
}
```

Now here’s the custom Hook `useTrivialRenderProps`:

```javascript
function useTrivialRenderProps() {
  const [data, setData] = useState([])
  const [loading, setLoading] = useState(false)
 return {
    data,
    loading,
  }
}
```
And that’s it!

```javascript
// before
class TrivialRenderProps extends Component {
  state = {
    loading: false,
    data: []
  }
  render() {
    return this.props.children(this.state)
  }
}

function ConsumeTrivialRenderProps() {
  return <TrivialRenderProps>
    {({loading, data}) => {
      return <pre>
        {`loading: ${loading}`} <br />
        {`data: [${data}]`}
      </pre>
    }}
  </TrivialRenderProps>
}

// after
function useTrivialRenderProps() {
  const [data, setData] = useState([])
  const [loading, setLoading] = useState(false)

  return {
    data,
    loading,
  }
}

function ConsumeTrivialRenderProps() {
  const { loading, setLoading, data } = useTrivialRenderProps()
  return <pre>
    {`loading: ${loading}`} <br />
    {`data: [${data}]`}
  </pre>
}
```

## 4. Handling state initializers

It is not uncommon to have class components where certain state properties are initialized based off of some computation. Here’s a basic example:

```javascript
class MyComponent extends Component {
  constructor(props) {
    super(props)
    this.state = { token: null }
    if (this.props.token) {
      this.state.token = this.props.token
    } else {
      token = window.localStorage.getItem('app-token');
      if (token) {
        this.state.token = token
      }
    }
  }
}
```

This is a simple example, but it shows a generic problem. It’s possible that as soon as your component mounts, you set some initial state in the `constructor` based on some computations.

In this example, we check if there’s a `token` prop passed in or if there’s an `app-token` key in local storage, and then we set state based off that. Upon refactoring to Hooks, how do you handle such logic to set initial state?

Perhaps a lesser-known feature of the `useState` Hook is that the `initialState` parameter you pass to the `useState` Hook — `useState(initialState)` — may also be a function!

Whatever you return from this function is then used as the `initialState`. Here’s what the component looks like after it’s been refactored to use Hooks:

```javascript
function MyComponent(props) {
   const [token, setToken] = useState(() => {
     if(props.token) {
       return props.token
     } else {
       tokenLocal = window.localStorage.getItem('app-token');
       if (tokenLocal) {
         return tokenLocal
       }
     }
   })
}
```

Technically, the logic stays almost the same. What’s important here is that you can use a function in useState if you need to initialize state based off of some logic.
